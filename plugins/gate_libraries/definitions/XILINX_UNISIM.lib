library (XILINX_UNISIM) {
    define(cell);

    cell(LUT1) {
        lut ("lut_out") {
            data_category     : "generic";
            data_identifier   : "INIT";
            bit_order         : "ascending";
        }
        pin(I0) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "lut_out";
        }
    }

    cell(LUT2) {
        lut ("lut_out") {
            data_category     : "generic";
            data_identifier   : "INIT";
            bit_order         : "ascending";
        }
        pin(I0) {
            direction: input;
        }
        pin(I1) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "lut_out";
        }
    }

    cell(LUT3) {
        lut ("lut_out") {
            data_category     : "generic";
            data_identifier   : "INIT";
            bit_order         : "ascending";
        }
        pin(I0) {
            direction: input;
        }
        pin(I1) {
            direction: input;
        }
        pin(I2) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "lut_out";
        }
    }

    cell(LUT4) {
        lut ("lut_out") {
            data_category     : "generic";
            data_identifier   : "INIT";
            bit_order         : "ascending";
        }
        pin(I0) {
            direction: input;
        }
        pin(I1) {
            direction: input;
        }
        pin(I2) {
            direction: input;
        }
        pin(I3) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "lut_out";
        }
    }

    cell(LUT5) {
        lut ("lut_out") {
            data_category     : "generic";
            data_identifier   : "INIT";
            bit_order         : "ascending";
        }
        pin(I0) {
            direction: input;
        }
        pin(I1) {
            direction: input;
        }
        pin(I2) {
            direction: input;
        }
        pin(I3) {
            direction: input;
        }
        pin(I4) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "lut_out";
        }
    }

    cell(LUT6) {
        lut ("lut_out") {
            data_category     : "generic";
            data_identifier   : "INIT";
            bit_order         : "ascending";
        }
        pin(I0) {
            direction: input;
        }
        pin(I1) {
            direction: input;
        }
        pin(I2) {
            direction: input;
        }
        pin(I3) {
            direction: input;
        }
        pin(I4) {
            direction: input;
        }
        pin(I5) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "lut_out";
        }
    }

    cell(GND) {
        pin(G) {
            direction: output;
            function: "0";
        }
    }

    cell(VCC) {
        pin(P) {
            direction: output;
            function: "1";
        }
    }

    cell(INV) {
        pin(I) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "!I";
        }
    }

    cell(XORCY) {
        pin(CI) {
            direction: input;
        }
        pin(LI) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "CI ^ LI";
        }
    }

    cell(MUXCY) {
        pin(CI) {
            direction: input;
        }
        pin(DI) {
            direction: input;
        }
        pin(S) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "(!S & DI) | (S & CI)";
        }
    }

    cell(MUXF5) {
        pin(I0) {
            direction: input;
        }
        pin(I1) {
            direction: input;
        }
        pin(S) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "(!S & I0) | (S & I1)";
        }
    }

    cell(MUXF7) {
        pin(I0) {
            direction: input;
        }
        pin(I1) {
            direction: input;
        }
        pin(S) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "(!S & I0) | (S & I1)";
        }
    }

    cell(MUXF8) {
        pin(I0) {
            direction: input;
        }
        pin(I1) {
            direction: input;
        }
        pin(S) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "(!S & I0) | (S & I1)";
        }
    }

    cell(MUXF9) {
        pin(I0) {
            direction: input;
        }
        pin(I1) {
            direction: input;
        }
        pin(S) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "(!S & I0) | (S & I1)";
        }
    }

    cell(FD) {
        ff ("IQ" , "IQN") {
            next_state          : "D";
            clocked_on          : "C";
        }
        pin(C) {
            direction: input;
            clock: true;
        }
        pin(D) {
            direction: input;
        }
        pin(Q) {
            direction: output;
            function: "IQ";
        }
    }

    cell(FDR) {
        ff ("IQ" , "IQN") {
            next_state          : "D & !R";
            clocked_on          : "C";
        }
        pin(C) {
            direction: input;
            clock: true;
        }
        pin(D) {
            direction: input;
        }
        pin(R) {
            direction: input;
        }
        pin(Q) {
            direction: output;
            function: "IQ";
        }
    }

    cell(FDS) {
        ff ("IQ" , "IQN") {
            next_state          : "D | S";
            clocked_on          : "C";
        }
        pin(C) {
            direction: input;
            clock: true;
        }
        pin(D) {
            direction: input;
        }
        pin(S) {
            direction: input;
        }
        pin(Q) {
            direction: output;
            function: "IQ";
        }
    }

    cell(FDE) {
        ff ("IQ" , "IQN") {
            next_state          : "D";
            clocked_on          : "CE & C";
        }
        pin(C) {
            direction: input;
            clock: true;
        }
        pin(CE) {
            direction: input;
        }
        pin(D) {
            direction: input;
        }
        pin(Q) {
            direction: output;
            function: "IQ";
        }
    }

    cell(FDCE) {
        ff ("IQ" , "IQN") {
            next_state          : "D";
            clocked_on          : "CE & C";
            clear               : "CLR";
        }
        pin(C) {
            direction: input;
            clock: true;
        }
        pin(CE) {
            direction: input;
        }
        pin(CLR) {
            direction: input;
        }
        pin(D) {
            direction: input;
        }
        pin(Q) {
            direction: output;
            function: "IQ";
        }
    }

    cell(FDPE) {
        ff ("IQ" , "IQN") {
            next_state          : "D";
            clocked_on          : "CE & C";
            preset              : "PRE";
        }
        pin(C) {
            direction: input;
            clock: true;
        }
        pin(CE) {
            direction: input;
        }
        pin(D) {
            direction: input;
        }
        pin(PRE) {
            direction: input;
        }
        pin(Q) {
            direction: output;
            function: "IQ";
        }
    }

    cell(FDRE) {
        ff ("IQ" , "IQN") {
            next_state          : "D & !R";
            clocked_on          : "CE & C";
        }
        pin(C) {
            direction: input;
            clock: true;
        }
        pin(CE) {
            direction: input;
        }
        pin(D) {
            direction: input;
        }
        pin(R) {
            direction: input;
        }
        pin(Q) {
            direction: output;
            function: "IQ";
        }
    }

    cell(FDSE) {
        ff ("IQ" , "IQN") {
            next_state          : "D | S";
            clocked_on          : "CE & C";
        }
        pin(C) {
            direction: input;
            clock: true;
        }
        pin(CE) {
            direction: input;
        }
        pin(D) {
            direction: input;
        }
        pin(S) {
            direction: input;
        }
        pin(Q) {
            direction: output;
            function: "IQ";
        }
    }

    cell(BUF) {
        pin(I) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "I";
        }
    }
    cell(BUFG) {
        pin(I) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "I";
        }
    }
    cell(BUFH) {
        pin(I) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "I";
        }
    }
    cell(IBUF) {
        pin(I) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "I";
        }
    }
    cell(OBUF) {
        pin(I) {
            direction: input;
        }
        pin(O) {
            direction: output;
            function: "I";
        }
    }

}
